import { fc, it } from '@fast-check/jest'

import * as arb from '@hashers/arbitraries'
import { MAX_ARRAY_LENGTH_ERROR, NEGATIVE_COUNT_ERROR, hashStates, initStates } from './Hasher'

/**
 * The maximum number of hash states to be generated by hashStates or
 * initStates in any given test. Chosen to be small enough to ensure
 * that the tests run quickly, but large enough to ensure that the
 * tests are meaningful.
 */
const GENERATION_LIMIT = 10_000

describe('the hashStates function', () => {
  it.prop({
    hasher: arb.hasher(),
    state: fc.anything(),
    count: fc.double({ max: -1 })
  })(
    'should throw an error if count is negative or NaN',
    ({ hasher, state, count }) => {
      expect(() => hashStates(hasher, state, count))
        .toThrow(NEGATIVE_COUNT_ERROR(count))
    }
  )

  it.prop({
    hasher: arb.hasher(),
    state: fc.anything(),
    count: fc.double({ min: 0xFFFFFFFF, noNaN: true })
  })(
    'should throw an error if count is greater than the max array length',
    ({ hasher, state, count }) => {
      expect(() => hashStates(hasher, state, count))
        .toThrow(MAX_ARRAY_LENGTH_ERROR(count))
    }
  )

  it.prop({
    hasher: arb.hasher(),
    state: fc.anything(),
    count: fc.nat({ max: GENERATION_LIMIT })
  })(
    'should return an array with length equal to the given count',
    ({ hasher, state, count }) => {
      expect(hashStates(hasher, state, count))
        .toHaveLength(Math.ceil(count))
    }
  )

  it.prop({
    hasher: arb.hasher(),
    state: fc.anything(),
    count: fc.integer({ min: 1, max: GENERATION_LIMIT })
  })(
    'should return an array whose first element is the given state',
    ({ hasher, state, count }) => {
      expect(hashStates(hasher, state, count)[0])
        .toBe(state)
    }
  )

  it.prop({
    hasher: arb.hasher(),
    state: fc.anything(),
    nums:
      fc.integer({ min: 2, max: GENERATION_LIMIT })
        .chain(count => fc.record({
          count: fc.constant(count),
          index: fc.integer({ min: 0, max: count - 2 })
        }))
  })(
    "should return an array in which any two consecutive elements are related by the hasher's nextState function",
    ({ hasher, state, nums: { count, index } }) => {
      const states = hashStates(hasher, state, count)
      expect(states[index + 1]).toBe(hasher.nextState(states[index]))
    }
  )
})

describe('the initStates function', () => {
  it.prop({
    hasher: arb.hasher(),
    seed: fc.string(),
    count: fc.double({ max: -1 })
  })(
    'should throw an error if count is negative or NaN',
    ({ hasher, seed, count }) => {
      expect(() => initStates(hasher, seed, count))
        .toThrow(NEGATIVE_COUNT_ERROR(count))
    }
  )

  it.prop({
    hasher: arb.hasher(),
    seed: fc.string(),
    count: fc.double({ min: 0xFFFFFFFF, noNaN: true })
  })(
    'should throw an error if count is greater than the max array length',
    ({ hasher, seed, count }) => {
      expect(() => initStates(hasher, seed, count))
        .toThrow(MAX_ARRAY_LENGTH_ERROR(count))
    }
  )

  it.prop({
    hasher: arb.hasher(),
    seed: fc.string(),
    count: fc.nat({ max: GENERATION_LIMIT })
  })(
    'should return the same value as hashStates(hasher, hasher.initState(seed), count)',
    ({ hasher, seed, count }) => {
      expect(initStates(hasher, seed, count))
        .toEqual(hashStates(hasher, hasher.initState(seed), count))
    }
  )
})
